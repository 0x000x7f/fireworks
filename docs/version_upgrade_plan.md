# 日本花火シミュレーション：開発ロードマップ＆技術仕様書

## 1. はじめに：AIエージェントへのブリーフィング

あなたは「日本花火シミュレーション」プロジェクトのリード開発エージェントです。このドキュメントは、v1.0の安定版を基盤とし、v2.0の高度な演出システムに至るまでの開発ロードマップを定義します。

各バージョンごとに設定された**技術仕様（Technical Specification）**と**タスクリスト（Task List）**に基づき、段階的に開発を進めてください。設計の意図を正確に汲み取り、高品質なコードを生成することがあなたの責務です。

---

## 2. 現在のバージョン：v1.0 (基盤)

*   **ステータス**: 実装完了・安定版
*   **コア機能**:
    *   球状の「丸割物」花火
    *   和風カラーパレット
    *   基本的な物理モデル（重力、残像）
    *   Mavenによるビルド環境

---

## 3. バージョンアップ計画

### 🆙 v1.1: 物理モデルと視覚表現の深化

**目標:** より現実に近い、繊細で美しい物理挙動と光の表現を実装する。

#### **【技術仕様】**

1.  **火花の速度分布の改善:**
    *   **現状:** `random(min, max)` による一様分布。
    *   **改善:** 火花が中心部で密集し、外側ほど疎になるよう、**平方根（`sqrt`）**を用いた分布に変更します。これにより、爆発直後のコアの輝きが強調されます。
    *   **実装方針:** `Firework.explode()`内で、パーティクルの初速を計算する際に以下を適用。
        ```java
        // 例: 速度を0から8の間で分布させる
        float speedMagnitude = 8.0f * sqrt(random(1)); 
        ```

2.  **滞空時間の表現（指数減衰）:**
    *   **現状:** `lifespan -= CONSTANT;` という線形減衰。
    *   **改善:** `lifespan *= DECAY_RATE;` という**指数関数的減衰**に変更します。これにより、火花は最初はゆっくりと光を失い、最後にスッと消える、より自然な「間」が生まれます。
    *   **実装方針:** `Particle.update()`内の寿命計算を以下に変更。
        ```java
        // 例: 毎フレーム1%ずつ光量が減る
        final float LIFESPAN_DECAY_RATE = 0.99f; 
        lifespan *= LIFESPAN_DECAY_RATE;
        ```
        `isDead()`の判定は `lifespan < 1.0f` など微小な閾値で行います。

3.  **点滅・光量ブレの導入:**
    *   **目的:** 単調な減衰ではなく、星が瞬くような有機的な光の変化を加える。
    *   **実装方針:** `Particle.display()`内で、描画ごとに明るさ（またはサイズ）に僅かなランダム性を加えます。
        ```java
        // 描画時のアルファ値に揺らぎを追加
        float flicker = random(-20, 20);
        p.fill(this.c, this.lifespan + flicker);

        // 描画時のサイズに揺らぎを追加
        float sizeFlicker = random(0.8, 1.2);
        p.ellipse(pos.x, pos.y, this.size * sizeFlicker, this.size * sizeFlicker);
        ```

4.  **夜空の残像効果のパラメータ化:**
    *   **目的:** 描画品質の調整を容易にする。
    *   **実装方針:** `PMainFireworks`の`draw()`冒頭の`fill(0, 0, 0, alpha)`の`alpha`値を定数化し、調整可能にします。
        ```java
        // PMainFireworks.java
        final int BACKGROUND_ALPHA = 15; // この値を調整することで残像の濃さが変わる
        // ... in draw()
        p.fill(0, BACKGROUND_ALPHA);
        ```

#### **【v1.1 タスクリスト】**

-   [ ] **1. 設計文書作成:** `docs/hanabi_design_v_1_1.md` を作成し、本セクションの技術仕様を転記する。
-   [ ] **2. 速度分布変更:** `Firework.java` の `explode()` メソッドを修正し、火花の初速計算に `sqrt(random(1))` を導入する。
-   [ ] **3. 寿命減衰変更:** `Particle.java` の `update()` メソッドを修正し、`lifespan` を指数関数的減衰（乗算）に変更する。`isDead()` の閾値も調整する。
-   [ ] **4. 点滅効果実装:** `Particle.java` の `display()` メソッドを修正し、アルファ値またはサイズにランダムな揺らぎを追加する。
-   [ ] **5. パラメータ整理:** `PMainFireworks.java` に `LIFESPAN_DECAY_RATE` と `BACKGROUND_ALPHA` を final 定数として定義する。
-   [ ] **6. ログ更新:** `PROGRESS_LOG.md` に v1.1 開発開始と完了を記録する。
-   [ ] **7. README更新:** `README.md` にバージョン履歴セクションを追加し、v1.1の変更点を記載する。

---

### 🆙 v1.2: インタラクションの導入

**目標:** ユーザーがシミュレーションに直接介入できる機能を実装し、操作する楽しさを提供する。

#### **【技術仕様】**

1.  **マウスによる手動打ち上げ:**
    *   **トリガー:** `mousePressed()` イベント。
    *   **実装方針:** `PMainFireworks`に`mousePressed()`メソッドを実装。クリックされた座標を終点とし、画面下部中央からそこへ向かう初速ベクトルを計算して新しい`Firework`インスタンスを生成・追加する。
2.  **キーボードショートカット:**
    *   **トリガー:** `keyPressed()` イベント。
    *   **機能:**
        *   `'r'` または `'R'`: 全ての花火をクリア (`fireworks.clear()`)。
        *   `' '` (スペースキー): 画面中央下部からランダムな花火を1発打ち上げる。
3.  **GUIによるパラメータ調整 (発展):**
    *   **ライブラリ:** Processingに標準で組み込まれている`controlP5`ライブラリの利用を検討。
    *   **対象パラメータ:** `FIREWORK_SPAWN_RATE`, `BACKGROUND_ALPHA` などをスライダーでリアルタイムに変更可能にする。

#### **【v1.2 タスクリスト】**

-   [ ] `PMainFireworks.java` に `mousePressed()` メソッドを追加し、手動打ち上げ機能を実装する。
-   [ ] `PMainFireworks.java` に `keyPressed()` メソッドを追加し、リセットと追加打ち上げのショートカットを実装する。
-   [ ] (発展) `pom.xml` に `controlP5` の依存関係を追加し、GUIスライダーを実装する。

---

### 🆙 v1.3: 花火形状の多様化

**目標:** 「丸割物」以外の日本の伝統的な花火を実装し、表現の幅を広げる。

#### **【技術仕様】**

1.  **`FireworkType` Enumの導入:**
    *   花火の種類を管理するため、`enum FireworkType { MARUWARI, KIKU, SENRIN, ... }` を作成する。
    *   `Firework`クラスはコンストラクタでこの`enum`を受け取り、`explode()`の挙動を切り替える。
2.  **新形状のアルゴリズム:**
    *   **菊 (Kiku):**
        *   特徴: 火花が長く尾を引く。
        *   実装: パーティクルの`lifespan`を通常より長く設定。`Particle`クラスに「親」の色を少しずつ混ぜながら軌跡を描く処理を追加。
    *   **千輪菊 (Senrin-giku):**
        *   特徴: 大きな爆発の中に、小さな花火が多数同時に開く。
        *   実装: `Firework.explode()`が、`Particle`の代わりに多数の小さな`Firework`インスタンス（ミニ花火）を生成する。ミニ花火は少しだけ移動した後に再度`explode()`を呼び出し、パーティクルを放出する（再帰的構造）。
    *   **型物 (Katamono - 例: ハート型):**
        *   特徴: 特定の形状を描く。
        *   実装: `explode()`時に、カーディオイド曲線などの数式を用いてパーティクルの初速ベクトルを計算する。

#### **【v1.3 タスクリスト】**

-   [ ] `FireworkType` enum を作成する。
-   [ ] `Firework`クラスをリファクタリングし、`FireworkType`に応じて爆発パターンが変わるようにする。
-   [ ] 「菊」「千輪菊」「型物」の各アルゴリズムを実装する。

---

### 🆙 v1.4: メディア統合と演出強化

**目標:** 音響や派手な視覚効果を加え、よりショーに近い体験を創出する。

#### **【技術仕様】**

1.  **音響効果:**
    *   **ライブラリ:** ProcessingのSoundライブラリ (`processing.sound.*`) を利用。
    *   **実装:**
        *   打ち上げ時: `Firework`コンストラクタで「ヒュー」という上昇音 (`SoundFile.play()`)。
        *   爆発時: `explode()`メソッドで「ドーン」という爆発音 (`SoundFile.play()`)。
2.  **爆発閃光 (Flash):**
    *   **実装:** `Firework.explode()`が呼び出されたフレームで、`PMainFireworks`にフラグを立てる。`draw()`メソッドの最後で、フラグが立っていれば画面全体を半透明の白で一瞬覆う (`background(255, 150)`)。

#### **【v1.4 タスクリスト】**

-   [ ] `pom.xml` にProcessing Soundライブラリの依存関係を追加する。
-   [ ] 音声ファイル（例: `launch.wav`, `explode.wav`）を`src/main/resources`に配置する。
-   [ ] `Firework`クラスに音再生ロジックを実装する。
-   [ ] 爆発閃光エフェクトを実装する。

---

## 4. 長期構想 v2.0: 演出・展示システムへの昇華

**目標:** シミュレーションから、シーケンス制御可能な「花火ショー演出システム」へと進化させる。

*   **ショースケジューラ:** タイムライン（JSONやCSVファイル）を読み込み、指定のタイミング・位置・種類の花火を打ち上げるシステム。
*   **外部連携:** OSCやWebSocket APIを実装し、他のアプリケーション（音楽ソフト、VJソフト等）からの制御を可能にする。
*   **Web展開:** Processing.js または p5.js への移植を検討し、GitHub Pagesでインタラクティブデモを公開する。